# 关于rcore的学习
## 2023.10.23
1. 因为懒得配置环境，所以个人之间下载了rcore book给的虚拟机，所以环境没怎么花费时间，一切正常。

## 2023.10.24-10.25
1. 开始阅读rcore book, 书中用了很多史前生物恐龙、邓氏鱼等来命名操作系统，很特别，充满趣味，看得很舒服。晚上跑去leetcode用Rust刷了一道题。前面两章很愉快，一切正常。

## ch3
1. 虚拟机里用vscode总是有时候莫名其妙的卡住，忍不住了，这个时候决定跑回WSL，重新配置，重新开始，由于吸取群里大家的踩坑记录，所以这次配置环境，虽然遇到各种，磕磕绊绊，但总算成功完成了。
开始第三章实验
2. 第一次遇到这种刚开始迷迷糊糊终于把书看完了，但是一看到题目的那一瞬间，还是很懵逼的，完全不知道从何做起，
懵逼了两三天后，终于在慢慢看源码的过程中，开始明白了一点整个代码的框架，总算把结果过了。
3. 完成步骤
    * 首先在TaskControl中增加相应的元素来记录需要的值：start_time等，并在相应初始化的地方进行初始化
    * 然后在任务第一次被调用的地方记录第一次被调用的时间，并添加一个公共方法，能够获取任务的相关信息便可完成

## ch4
    这部分的内容中，为 Rcore 引入了虚拟内存，为地 址空间加上了一层抽象，地址空间
    刚学计算机的时候，个人非常总喜欢将所有代码放在一个文件里，觉得分开各种代码很是麻烦。后来因为学习深入，开始对分离代码，抽象多了很多体会。特别是在学计算机网络的TCP/IP模型和操作系统的时候，对**抽象，加层**的思想确实是不断体会，不断明白了那句话“在计算机中，没有什么是不能加一层解决不了的”。现在来好好感受在ch4中的抽象加一层。
    1. 为什么要添加一层抽象层：
        * 从应用开发的角度看，需要应用程序决定自己会被加载到哪个物理地址运行，需要直接访问真实的物理内存。这就要求应用开发者对于硬件的特性和使用方法有更多了解，产生额外的学习成本，也会为应用的开发和调试带来不便
        * 从内核的角度来看，将直接访问物理内存的权力下放到应用会使得它难以对应用程序的访存行为进行有效管理，已有的特权级机制亦无法阻止很多来自应用程序的恶意行为。
    2. 该抽象层要完成的目标：
    
        * 透明 ：应用开发者可以不必了解底层真实物理内存的硬件细节，且在非必要时也不必关心内核的实现策略， 最小化他们的心智负担；

        * 高效 ：这层抽象至少在大多数情况下不应带来过大的额外开销；

        * 安全 ：这层抽象应该有效检测并阻止应用读写其他应用或内核的代码、数据等一系列恶意行为。
    3. lab 看不懂，很懵逼，卡了两三天，一两天，一行代码都写不出来。最后看rcore的各种学习资料，也大致明白了思路，总算完成了。

## ch5
复习了操作系统课上的进程和程序，各种调度算法和进程有关的都学过，但这次，又多了些体会。听胡学长上课，看他的飞书。发现学长蛮喜欢从多角度来看待os里面的东西：从应用程序看，从操作系统看……。收获颇多
    * 对于进程、程序、可执行文件等的了解更加深入了
        1.  进程是在操作系统管理下的程序的一次执行过程，程序是一个静态的概念。
        2. 可执行文件是一张“蓝图”：一张编译器解析源代码之后总结出的一张记载如何利用各种硬件资源进行一轮生产流程的 **蓝图**
        3. 加载同一个可执行文件的两个进程也是不同的：它们的启动时间、占据的硬件资源、输入数据均有可能是不同的，这些条件均会导致它们是不一样的执行过程。
        4. 对于创建进程需要fork()和exec()两个系统调用而不只是一个系统调用。两个组合更加灵活，fork是为了 exec 一个新应用提供空间，然后exec可以读取不同的elf文件，执行不同的操作。
看教程，本章大部分内容都学过，觉得实验应该挺简单的，没想到，结果却是彻底懵了。怎么做都不过，不知道怎么做。一直不知道怎么做，连续三天摆烂，很懵逼。周末快过完了，周日赶紧干，总算在周日晚上快十点干完了，然后前面没怎么写的reports。总算算是干结束了。blog总结还没写，deadline已经过了。明天好好写blog.